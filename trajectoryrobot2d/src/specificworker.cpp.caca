/*
 *    Copyright (C) 2006-2010 by RoboLab - University of Extremadura
 *
 *    This file is part of RoboComp
 *
 *    RoboComp is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    RoboComp is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with RoboComp.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "specificworker.h"

/**
* \brief Default constructor
*/

SpecificWorker::SpecificWorker(MapPrx& mprx, QWidget *parent) : GenericWorker(mprx)
{
	this->params = params;
	
	innerModel = new InnerModel("/home/robocomp/robocomp/Files/InnerModel/betaWorld.xml");  ///CHECK IT CORRESPONDS TO RCIS
	innerModel->setUpdateTranslationPointers("base", &(bState.x), NULL, &(bState.z));
	innerModel->setUpdateRotationPointers("base", NULL, &(bState.alpha), NULL);
	moveBoxes();
 
	try { differentialrobot_proxy->getBaseState(bState); }
	catch(const Ice::Exception &ex) { cout << ex << endl; }
	try { laserData = laser_proxy->getLaserData(); }
	catch(const Ice::Exception &ex) { cout << ex << endl; }

	innerModel->update();

	planner = new Planner(innerModel);

	cleanWorld();
	
	//road.readRoadFromFile(innerModel, "puntos2.txt");
	
	bool res = planner->computePath(QVec::vec3(0,0,1000));
	
	
	
	road.readRoadFromList( planner->getPath() );

	qDebug() << res << planner->getPath() << road.size();
	
	Q_ASSERT_X(road.size() > 0, "SpecificWorker constructor", "road is empty");
	
	if( road.isEmpty()) 
		qFatal("No path found");
	
	elasticband = new ElasticBand(innerModel, innermodelmanager_proxy);
	//elasticband->setRoad(road, laserData);
	
  pointstoroad = new PointsToRoad(innerModel, innermodelmanager_proxy);
  pointstoroad->setRoad(road);
	
	controller = new Controller(2);
	
	sleep(1);
	
	road.draw(innermodelmanager_proxy, innerModel);
		
}

/**
* \brief Default destructor
*/
SpecificWorker::~SpecificWorker()
{
}

void SpecificWorker::compute( )
{
	try{	differentialrobot_proxy->getBaseState(bState);  }  
	catch(const Ice::Exception &ex){ cout << ex << endl;};
	try{	laserData = laser_proxy->getLaserData();}  
	catch(const Ice::Exception &ex){ cout << ex << endl;};
	
	//moveBoxes(); 
	
	innerModel->update();
		
	elasticband->update( road, laserData );
	
	pointstoroad->update(road);
	
	elasticband->update( road, laserData );
	
//	controller->update(differentialrobot_proxy, road);

// 	road.printRobotState(innerModel);
	
	road.draw(innermodelmanager_proxy, innerModel);	
	
	
	if(road.finish == true)
		qFatal("GOODBYE, FINISHED ROAD");
	
	if(road.requiresReplanning == true)
	{
		emit kill();
		qFatal("GOODBYE, PLANNING REQUIRED");
	}

}

bool SpecificWorker::setParams(RoboCompCommonBehavior::ParameterList params)
{
	//qDebug() << QString::fromStdString(params["PointsFile"].value);
	timer.start(100);
	
	return true;
};

void SpecificWorker::moveBoxes()
{
	static bool firstTime = true;
	static bool flip = true;
	static QTime reloj = QTime::currentTime();
	long int maxTime = 2000000;

	RoboCompInnerModelManager::Pose3D pose,pose2;
	pose.x=0; pose.y=100; pose.z=0;
	pose2.x=885; pose2.y=100; pose2.z=1200;
	//pose2.x=-85; pose2.y=0; pose2.z=1200;
	
	if( firstTime == true )
	{
		try
		{
			innermodelmanager_proxy->setPoseFromParent("caja1", pose);
			innerModel->updateTranslationValues("caja1", pose.x, pose.y, pose.z);	
			innermodelmanager_proxy->setPoseFromParent("caja2", pose2);
			innerModel->updateTranslationValues("caja2", pose2.x, pose2.y, pose2.z);
		} 
		catch (const RoboCompInnerModelManager::InnerModelManagerError &e )
		{ std::cout << e << std::endl; }
		firstTime = false;
	}	
	if( reloj.elapsed() < maxTime)
	try
	{
		innermodelmanager_proxy->getPoseFromParent("caja1", pose);
		if (flip )
			if( pose.x < 1000)
				pose.x += 15;
			else
				flip = false;
		else 
			if (pose.x > -1000)
				pose.x -= 15;
			else
				flip = true;
		
		innermodelmanager_proxy->setPoseFromParent("caja1", pose);
		innerModel->updateTranslationValues("caja1", pose.x, pose.y, pose.z);	
		
		innermodelmanager_proxy->getPoseFromParent("caja2", pose2);
		if (pose2.x < 2000)
			pose2.x += 0;
		innermodelmanager_proxy->setPoseFromParent("caja2", pose2);
		innerModel->updateTranslationValues("caja2", pose2.x, pose2.y, pose2.z);	

	} 
	catch (const RoboCompInnerModelManager::InnerModelManagerError &e )
	{ std::cout << e << std::endl; }
	
}

void SpecificWorker::cleanWorld()
{
	qDebug() << "SpecificWorker::CleaningWorld()";
	//RcisDraw::removeObject(innermodelmanager_proxy, "nose");
	for (int i = 0 ; i < 80; i++) 
	{
		RcisDraw::removeObject(innermodelmanager_proxy, QString("p_" + QString::number(i) + "_line"));
		RcisDraw::removeObject(innermodelmanager_proxy, QString("p_" + QString::number(i) + "_lineA"));
		RcisDraw::removeObject(innermodelmanager_proxy, QString("p_" + QString::number(i) + "_mesh"));
		RcisDraw::removeObject(innermodelmanager_proxy, QString("p_" + QString::number(i) + "_point"));
		RcisDraw::removeObject(innermodelmanager_proxy, QString("b_" + QString::number(i) + "_mesh"));
		RcisDraw::removeObject(innermodelmanager_proxy, QString("b_" + QString::number(i) + "_line"));
		RcisDraw::removeObject(innermodelmanager_proxy, QString("b_" + QString::number(i)));
		RcisDraw::removeObject(innermodelmanager_proxy, QString("p_" + QString::number(i)));
	}
}
